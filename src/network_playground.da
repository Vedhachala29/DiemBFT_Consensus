from object_types import MsgType
from logger_util import LOGGER

class NetworkPlayground(process):
    def setup(config, config_id: int, scenario,scenario_id, validators):

        LOGGER.replicas = validators
        LOGGER.process_id = "NetworkPlayground"
        LOGGER.filename = '../logs/config' + str(config_id) + '/' + 'scenario' + str(scenario_id) \
            + '/' + LOGGER.process_id + ".log"

        self.last_executed_round = {}
        self.last_committed_round = {}
        self.txn_commit_order = {} # safety check
        self.nocommit_pool = set()
        self.scenario = scenario
        self.MIN_IDLE_ROUNDS = 6
        self.validators = validators
        self.Process_Completed = False
        self.msgtypestr = {
            MsgType.Proposal: 'Proposal',
            MsgType.Vote: "Vote",
            MsgType.Timeout: "Timeout",    
        }
        self.count_timeouts_latest_round = {}
        self.noprogress_validators = set()


    def run():
        await(self.Process_Completed == True)
    def receive(msg=('NetworkPlayground', source, round, msg, msgtype), from_=p):
        output(str(source), " sending ", msgtypestr[msgtype], 'at round ', round)
        destination = evaluate_destination(source, round, msgtype)
        if len(destination):
            send((msgtypestr[msgtype], msg, p), to=destination)
        
        if last_executed_round.get(source, -1) < round:
            count_timeouts_latest_round[source] = 0

        last_executed_round[source] = round
        check_no_commit_pool(source)
        count_timeouts_latest_round[source] = count_timeouts_latest_round[source] + 1
        # check_progress_on_timeout()
        if round >= scenario['max_rounds']:
            check_process_completion()


        
    def receive(msg=('CommitNotification', source, round, txns), from_=p):
        output('CommitNotification from: ', source, 'at round: ', round, ' txns: ', txns)
        last_committed_round[source] = round
        update_no_commit_pool(round)
        do_safety_check(source,txns)
        check_process_completion()
        output('cp 4')
        

    def evaluate_destination(source, round, msgtype):
        partition = []
        intended_destination = []
        PLF_list = scenario['rounds'][str(round)]['partitions']
        for partition_config in PLF_list:
            partition_sets  = partition_config[0]
            failtype = partition_config[1]
            # output("TEST11", source,  partition_sets)
            if failtype == "Failure_Type.NONE":
                for ipartition in partition_sets:
                    if source in ipartition:
                        partition = ipartition
        if msgtype in [MsgType.Proposal, MsgType.Timeout]:
            intended_destination = list(range(len(validators)))
        if msgtype == MsgType.Vote:
            next_leader = scenario['rounds'][str(round+1)]['leader']
            intended_destination = [next_leader]
            if str(next_leader) in config['twin']:
                intended_destination.append(config['twin'][str(next_leader)])
        
        destination = []
        d1 = []
        for validator_id in intended_destination:
            if validator_id in partition:
                d1.append(validator_id)
                destination.append(validators[validator_id])
        output("TEST2" , "destination: ", d1)
        return destination

    def check_no_commit_pool(source):
        
        if last_executed_round.get(source, 0) - last_committed_round.get(source, 0) >= MIN_IDLE_ROUNDS:
            nocommit_pool.add(source)
        if len(nocommit_pool) == 2*config['nfaulty']+1:
            ''' Liveliness Violation '''
            self.Process_Completed = True
            send(('DoneFromNP','Liveliness Violation'), to=parent())
    
    def update_no_commit_pool(source):
        if source not in nocommit_pool:
            return
        if last_executed_round.get(source, -1) - last_committed_round.get(source, -1) < MIN_IDLE_ROUNDS:
            nocommit_pool.remove(source)

    def do_safety_check(source, txns):
        if str(source) in config['twin']: # need not check safety for faulty nodes
            return
        last_commited_index = len(txn_commit_order.get(source, [])) - 1
        if last_commited_index == -1:
            txn_commit_order[source] = []
        out_of_order = False
        for command in txns:
            txn_commit_order[source].append(command)
            last_commited_index = last_commited_index + 1
            for i in range(0, len(validators)):
                if str(i) in config['twin']:
                    continue
                icommit_order = txn_commit_order.get(i, [])
                if len(icommit_order) <= last_commited_index or icommit_order[last_commited_index] == command: # in order with the current commit
                    continue
                else:
                    out_of_order = True
                    break
        if out_of_order:
            output('Safety Violated', )
            self.Process_Completed = True
            send(('DoneFromNP','Safety Violated'), to=parent())
    
    def check_process_completion():
        non_faulty_pendings_commits = False
        for i in range(0, len(validators)):
            if str(i) in config['twin']:
                continue
            if len(txn_commit_order.get(i, [])) < config['nclientops']:
                non_faulty_pendings_commits = True
                break
        if non_faulty_pendings_commits is False:
            self.Process_Completed = True
            send(('DoneFromNP','Execution Completed'), to=parent())
            return True
        else:
            return False
    
    def check_progress_on_timeout():
        violated = 0
        for i in range(0, len(validators)):
            if count_timeouts_latest_round.get(i,0) >= 2:
                violated = violated + 1
    
        if violated >= 2*config['nfaulty']+1:
            output('Network Playground: No Progress')
            self.Process_Completed = True
            send(('DoneFromNP','Liveness Violation'), to=parent())
            return True
        else:
            return False
        
        

