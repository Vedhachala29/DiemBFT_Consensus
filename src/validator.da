import sys

from leader_election import LeaderElection
from ledger import Ledger
from pacemaker import PaceMaker
from block_tree import BlockTree


class Validator(process):

    def setup(id: int, validators: list, public_keys: list, private_key):
        self.exit_flag = 0
        self.validators = validators
        self.modules = {}                    # A dictionary which stores all the modules' references
        self.modules.config = {
            "id": id,
            "nfaulty": 0
        }
        self.pace_maker = PaceMaker(self.modules,1)  # TODO delta, 1 is a place holder
        self.pace_maker_timer = 4
        self.leader_election = LeaderElection(self.modules, 5, 2)
        self.safety = Safety(self.modules, private_key, public_keys, 0, 0) # TODO Check this initialization
        self.block_tree = BlockTree(modules)
        self.modules['validators_list'] = validators
        self.ledger = Ledger(self.modules)
        self.pace_maker = PaceMaker(self.modules)
        self.leader_election = LeaderElection(self.modules, 5, 2)
        self.modules['ledger'] = self.ledger
        self.modules['pace_maker'] = self.pace_maker
        self.modules['block_tree'] = self.block_tree
        self.modules['leader_election'] = self.leader_election
        self.modules['safety'] = self.safety
        
    def run():
        output(self.leader_election.get_leader(1))
        
        while not self.exit_flag:
            self.round_done = False
            timer_duration = self.pace_maker.get_round_timer(10000)
            if await(self.round_done):
                output("Round " + self.pace_maker.current_round + " is done after awaiting")
            elif timeout(timer_duration):
                timeout_info = self.safety.make_timeout(self.pace_maker.current_round, self.block_tree.high_qc,
                                                        self.pace_maker.last_round_tc)
                
                timeout_msg  = TimeOutMsg(timeout_info, self.pace_maker.last_round_tc, self.modules.block_tree.high_commit_qc)
                send(('Timeout', timeout_msg), to=self.validators)

        await(self.exit_flag == 1)

    def receive(msg=(action, msg), from_=p):
        if action == 'Request':
            output('Request', msg)
        elif action == 'Local Timeout':
            output('Local Timeout', msg)
        elif action == 'Propose':
            process_proposal_message(b)
        elif action == 'Vote':
            output('Vote', msg)
        elif action == 'Timeout':
            output('Timeout', msg)
        else:
            output('Default')

    def process_certificate_qc(qc):
        modules.block_tree
    
    def process_proposal_message(P):
        process_certficate_qc(P.block.qc)
        process_certificate_qc(P)
        process_certifcate_qc(P.high_commit_qc)
        self.modules.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.modules.pace_maker.current_round
        leader = self.modules.pace_maker.get_leader(round)
        if P.block.round == round or P.sender != leader or P.block.author != leader:
            output("No Progress")
            return
        self.modules.block_tree.execute_and_insert(P)
        vote_msg = self.modules.safety.make_vote(P.block, P.last_round_tc)
        if vote_msg != None:
            send(('vote_message', ), to=self.validators[leader])

    def process_timout_message(M):
        process_certficate_qc(M.tmo_info.high_qc)
        process_certficate_qc(M.high_commit_qc)
        self.modules.pace_maker.advance_round_tc(M.last_round_tc)
        tc = self.modules.pace_maker.process_remote_timeout(M)
        if tc != None:
            self.modules.pace_maker.advance_round(tc)
            self.process_new_round_event(None)
    def process_vote_message(vote_msg):
        qc = self.modules.block_tree.process_vote(vote_msg)
        if qc != None:
            self.process_certifciate_qc(qc)
            process_new_round_event(None)
    
    def process_new_round_event(last_tc):
        if self.modules.config.id == self.modules.leader_election.get_leader(self.modules.pace_maker.current_round):
            b = self.modules.block_tree.generate_block(self.modules.mempool.get_transaction(), self.modules.pace_maker.current_round)
            for validator in self.modules.validators:
                send(('Propose',), to=validator)

