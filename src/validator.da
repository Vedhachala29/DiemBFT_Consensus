import sys

from leader_election import LeaderElection
from ledger import Ledger
from pacemaker import PaceMaker
from block_tree import BlockTree
from messages import TimeOutMsg, TimeoutInfo, TC, ProposalMsg
from mem_pool import MemPool
from safety import Safety


class Validator(process):

    def setup(id: int, validators: list, public_keys: list, private_key):
        self.exit_flag = 0
        self.validators = validators
        self.modules = {}                  # A dictionary which stores all the modules' references  # delta, 1 is a place holder
        self.modules["config"] = {}
        self.modules["config"]["id"] = id
        self.modules["config"]["nfaulty"] = 0
        self.pace_maker_timer = 4
        self.modules['validators_list'] = self.validators 
        self.safety = Safety(self.modules, private_key, public_keys, -1, -1) # TODO Check this initialization
        self.block_tree = BlockTree(modules)
        self.mem_pool = MemPool()
        self.ledger = Ledger(self.modules)
        self.pace_maker = PaceMaker(self.modules)
        self.leader_election = LeaderElection(self.modules, 5, 2)
        self.modules['ledger'] = self.ledger
        self.modules['pace_maker'] = self.pace_maker
        self.modules['block_tree'] = self.block_tree
        self.modules['leader_election'] = self.leader_election
        self.modules['safety'] = self.safety
        self.modules['mem_pool'] = self.mem_pool
        self.is_leader =  True if id == 0 else False
        self.sysinit = True
        
    def run():
        
        # self.round_done = False
        # output("Starting Timer")
        # while not self.round_done:
        #     timer_duration = self.pace_maker.get_round_timer(1000)
        #     await(timer_duration == 0)
        #     output("Round " , self.pace_maker.current_round , " is done after awaiting")
        #     self.round_done = True

            # elif timeout(timer_duration):
            #     timeout_info = self.safety.make_timeout(self.pace_maker.current_round, self.block_tree.high_qc,
            #                                             self.pace_maker.last_round_tc)
                
            #     timeout_msg  = TimeOutMsg(timeout_info, self.pace_maker.last_round_tc, self.modules["block_tree"].high_commit_qc)
            #     send(('Timeout', timeout_msg), to=self.validators)

        await(self.exit_flag == 1)

    def receive(msg=(action, msg), from_=p):
        if action == 'Local Timeout':
            output('Local Timeout', msg)
        elif action == 'Propose':
            # output(p, self.obj_to_string(msg), self.modules["config"]["id"])
            self.process_proposal_message(msg)
        elif action == 'vote_message':
            self.process_vote_message(msg)
        elif action == 'Timeout':
            output('Timeout', msg)
        elif action == 'Client':
            output("from client",p,msg)
            self.mem_pool.add_command_to_queue(msg)
            if self.sysinit:
                self.sysinit = False
                self.process_new_round_event(None)

        else:
            output('Default')


    def process_certificate_qc(qc):
        self.block_tree.process_qc(qc)
        # self.modules["leader_election"].update_leaders(qc)
        self.pace_maker.advance_round_qc(qc)

    def process_proposal_message(P):
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.modules["pace_maker"].current_round
        leader = self.modules["leader_election"].get_leader(round)
        
        if P.block.round != round or P.sender != leader or P.block.author != leader:
            output("No Progress")
            return
        
        self.modules["block_tree"].execute_and_insert(P.block)
        vote_msg = self.modules["safety"].make_vote(P.block, P.last_round_tc)
        # output('after makeout ',self.modules["config"]["id"], self.obj_to_string(vote_msg))
        if vote_msg != None:
            next_leader = self.modules["leader_election"].get_leader(round+1)
            # output(" next_leader: ", next_leader, "Current Round: ", round)
            send(('vote_message', vote_msg), to=self.validators[next_leader])

    def process_timeout_message(M):
        self.process_certficate_qc(M.tmo_info.high_qc)
        self.process_certficate_qc(M.high_commit_qc)
        self.modules["pace_maker"].advance_round_tc(M.last_round_tc)
        tc = self.modules["pace_maker"].process_remote_timeout(M)
        if tc != None:
            self.modules["pace_maker"].advance_round(tc)
            self.process_new_round_event(None)

    def process_vote_message(vote_msg):
        qc = self.modules["block_tree"].process_vote(vote_msg)
        if qc != None:
            # output('qc formed at :  ',self.modules["config"]["id"],  self.obj_to_string(qc))
            self.process_certificate_qc(qc)
            # output('btree :  ',self.modules["config"]["id"],  self.obj_to_string(self.modules["block_tree"].high_qc))
            self.process_new_round_event(None)
    
    def process_new_round_event(last_tc:None):
        # output('module', self.modules["leader_election"].get_leader(self.modules["pace_maker"].current_round), self.modules["config"]["id"])
        if self.modules["config"]["id"] == self.modules["leader_election"].get_leader(self.modules["pace_maker"].current_round):
            block = self.modules["block_tree"].generate_block(self.modules["config"], self.mem_pool.get_transaction(), self.modules["pace_maker"].current_round)
            block.author = self.modules["config"]["id"]
            proposal_msg = ProposalMsg(block, last_tc, self.block_tree.high_commit_qc,self.modules["config"]["id"], None)
            send(('Propose', proposal_msg), to=self.validators)
        else :
            output("I am not a leader", self.modules["config"]["id"])

    
    


