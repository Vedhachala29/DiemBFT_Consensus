import random
import math

class LeaderElection:
    def __init__(self, modules_map, window_size:int, exclude_size: int) -> None:
        self.modules_map = modules_map
        self.validators = self.modules_map['validators_list']
        print(modules_map)
        self.window_size = window_size
        self.exclude_size = exclude_size
        self.reputation_leaders = {}

    def election_reputation_leader(self, QC) -> int:
        active_validators = set()
        last_authors = set()                                      #Check if this is an ordered set or a set or list
        current_qc = QC
        iter=0
        while iter < self.window_size and len(last_authors) < self.exclude_size:
            current_block = self.modules_map['Ledger'].committed_block(current_qc.vote_info.parent_id)
            block_author =  current_block.author
            if iter < self.window_size:
                active_validators.add(current_qc.signatures.signers())
            if len(last_authors) < self.exclude_size:
                last_authors.add(block_author)
            current_qc = current_block.qc
            iter=iter+1
        active_validators.add(last_authors)                         # Assuming the operation is union.
        return random.choice(tuple(active_validators))              # Random choice from the tuple of active_validators

    def update_leader(self, QC) -> None:
        extended_round = QC.vote_info.parent_round
        qc_round = QC.vote_info.round
        current_round = self.modules_map['PaceMaker'].current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            self.reputation_leaders[current_round+1] = self.election_reputation_leader(QC)

    def get_leader(self, round:int):
        if round in self.reputation_leaders:
            return self.reputation_leaders[round] # check what is returned
        else:
            return math.floor(round/2) % len(self.validators)
    